# -*- coding: utf-8 -*-
"""EC2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1wZFal8e4hzm-Xn3Nx4dbLn2LAaydz7y6
"""

#LIBRARIES
import numpy as np
import matplotlib.pyplot as plt
from scipy import integrate

#FUNCTIONS FOR SIMULATION 1
springConst = 10
rest = .1
dampConst = 1
def get_norm(p):
  p0x,p0y,p1x,p1y,dp0x, dp0y,dp1x,dp1y = p[0],p[1],p[2],p[3],p[4],p[5],p[6],p[7]
  return np.sqrt((p1x-p0x)**2 + (p1y- p0y)**2)
def func_prob_1(p,t):
  p0x,p0y,p1x,p1y,dp0x, dp0y,dp1x,dp1y = p[0],p[1],p[2],p[3],p[4],p[5],p[6],p[7]
  norm = get_norm(p)
  dnorm = ((p1x-p0x)*(dp1x-dp0x)+(p1y-p0y)*(dp1y-dp0y))/norm
  component_multiplier = (springConst*(rest - norm) -dampConst*dnorm)/norm
  return [dp0x,dp0y,dp1x,dp1y,-(p1x-p0x)*component_multiplier,-(p1y-p0y)*component_multiplier, (p1x-p0x)*component_multiplier,(p1y-p0y)*component_multiplier]

#SIMULATION 1: INITIAL POSITION 1
times = np.array(range(1000))/100
initial_state_1 = [.07, 0, -.07, 0, 0, .5, 0, -.5]
points = integrate.odeint(func_prob_1, initial_state_1, times)
ds = list(map(get_norm, points))
xs1 = points[:,0] 
xs2 = points[:,2]
ys1 = points[:,1]
ys2 = points[:,3]

plt.scatter(xs1,ys1, s = .5, label = "p0 trajectory")
plt.scatter(xs2,ys2, s = .5, label = "p1 trajectory")
plt.title("Damped Oscillator: First intial condition trajectory of two unit point masses with positions p0 and p1")
plt.xlabel("x position")
plt.ylabel("y position")
plt.legend()
plt.figure()

plt.plot(times, ds)
plt.xlabel("time")
plt.ylabel("distance norm")
plt.title("distance norm of the masses over time")

#SIMULATION 1: INITIAL POSITION 2
times = np.array(range(1000))/100
initial_state_2 = [.07, 0, -.07, 0, .1, .6, .1, -.4]
points = integrate.odeint(func_prob_1, initial_state_2, times)
ds = list(map(get_norm, points))
xs1 = points[:,0] 
xs2 = points[:,2]
ys1 = points[:,1]
ys2 = points[:,3]

plt.scatter(xs1,ys1, s = .5, label = "p0 trajectory")
plt.scatter(xs2,ys2, s = .5, label = "p1 trajectory")
plt.title("Damped Oscillator: Second initial condition trajectory of two unit point masses with positions p0 and p1")
plt.xlabel("x position")
plt.ylabel("y position")
plt.legend()
plt.figure()

plt.plot(times, ds)
plt.xlabel("time")
plt.ylabel("distance norm")
plt.title("distance norm of the masses over time")

#FUNCTIONS FOR SIMULATION 2
def func_prob_2(p,t):
  p0x,p0y,p1x,p1y,dp0x, dp0y,dp1x,dp1y = p[0],p[1],p[2],p[3],p[4],p[5],p[6],p[7]
  norm = get_norm(p)
  dnorm = ((p1x-p0x)*(dp1x-dp0x)+(p1y-p0y)*(dp1y-dp0y))/norm
  component_multiplier = (springConst*(rest - norm) -dampConst*dnorm)/norm
  return [dp0x,dp0y,dp1x,dp1y,-(p1x-p0x)*component_multiplier - p0x*(1/((p0x**2+p0y**2)**(3/2))),-(p1y-p0y)*component_multiplier - p0y*(1/((p0x**2+p0y**2)**(3/2))), (p1x-p0x)*component_multiplier - p1x*(1/((p1x**2+p1y**2)**(3/2))),(p1y-p0y)*component_multiplier - p1y*(1/((p1x**2+p1y**2)**(3/2)))]

#SIMULATION 2
times = 12*np.pi*np.array(range(10000))/10000
initial_state_3 = [1, .05, 1, -.05, .4, 1, -.4, 1]
points = integrate.odeint(func_prob_2, initial_state_3, times)
ds = list(map(get_norm, points))
xs1 = points[:,0] 
xs2 = points[:,2]
ys1 = points[:,1]
ys2 = points[:,3]

angles = list( map (
    (lambda p: np.arccos( 
        np.dot((.5*p[0] + .5*p[2], .5*p[1] + .5*p[3]), (p[2]-p[0], p[3]-p[1]))/
        np.linalg.norm((.5*p[0] + .5*p[2], .5*p[1] + .5*p[3]))* np.linalg.norm((p[2]-p[0], p[3]-p[1])))), points)
)

plt.scatter(xs1,ys1, s = .5, label = "p0 trajectory")
plt.scatter(xs2,ys2, s = .5, label = "p1 trajectory")
plt.title("Damped Oscillator with Moon: Trajectory of two unit point masses with positions p0 and p1")
plt.xlabel("x position")
plt.ylabel("y position")
plt.legend()
plt.figure()

plt.plot(times, ds)
plt.xlabel("time")
plt.ylabel("distance norm")
plt.title("distance norm of the masses over time")
plt.figure()

plt.plot(times, angles)
plt.xlabel("time")
plt.ylabel("angle ")
plt.title("between distance vector and vector pointing to center of the points over time")